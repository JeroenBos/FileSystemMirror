using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading;
using System.Threading.Tasks;

/// <summary>
/// Retries an action which is assumed to start something. There are two distinguished failure modes:
/// - starting the something fails
/// - the something fails
/// </summary>
abstract class Retryer
{
	protected readonly TaskCompletionSource taskCompletionSource = new TaskCompletionSource();
	protected readonly RecoveryStrategy recoveryStrategy;
	protected readonly CancellationToken cancellationToken;
	protected readonly bool disposeOnError;
	public Task Task => taskCompletionSource.Task;


	protected Retryer(RecoveryStrategy recoveryStrategy, bool disposeOnError, CancellationToken cancellationToken)
	{
		this.recoveryStrategy = recoveryStrategy;
		this.cancellationToken = cancellationToken;
		this.disposeOnError = disposeOnError;

		if (cancellationToken.CanBeCanceled)
			cancellationToken.Register(OnCanceled);

	}
	protected abstract void Action(IReadOnlyList<Exception> exceptions);
	protected virtual void OnAbort(IReadOnlyList<Exception> exceptions)
	{
		taskCompletionSource.SetResult();
	}
	protected virtual void OnCanceled()
	{
		taskCompletionSource.SetCanceled();
	}

	protected virtual (bool Retry, bool ClearExceptions) ShouldRetry(object? sender, IReadOnlyList<Exception> exceptions)
	{
		bool canceled = cancellationToken.IsCancellationRequested;
		if (canceled)
		{
			this.OnCanceled();
			return (Retry: false, ClearExceptions: false);
		}

		bool retry = exceptions.Count <= recoveryStrategy.MaxAttempts;

		// we consider two kinds of errors:
		// - those raised when _starting_ the action (sender is null)
		// - those raised when _executing_ the action (sender is not null)
		bool clearExceptions = sender == null;
		return (retry, clearExceptions);
	}
	protected virtual ErrorEventHandler CreateErrorHandler(IReadOnlyList<Exception> exceptions)
	{
		var _exceptions = exceptions as List<Exception>;
		if (_exceptions == null)
			throw new ArgumentException("Exceptions must be (by reference) a list of exceptions generated by this class", nameof(exceptions));

		void onError(object? sender, ErrorEventArgs e)
		{
			if (disposeOnError && sender is IDisposable disposableSender)
				disposableSender.Dispose();

			var exception = e.GetException();
			_exceptions.Add(exception);

			var (retry, clearExceptions) = ShouldRetry(sender, exceptions);

			if (retry)
			{
				if (clearExceptions)
				{
					exceptions = new List<Exception>();
				}
				Start(_exceptions);
			}
			else
			{
				OnAbort(exceptions);
			}
		}
		return onError;
	}

	public Task Start()
	{
		Start(new List<Exception>());
		return this.Task;
	}

	private void Start(List<Exception> exceptions)
	{
		if (taskCompletionSource.Task.IsCompleted)
			throw new InvalidOperationException("Already completed");

		if (cancellationToken.IsCancellationRequested)
		{
			this.OnCanceled();
			return;
		}

		try
		{
			Action(exceptions);
		}
		catch (Exception e)
		{
			var errorHandler = CreateErrorHandler(exceptions);
			errorHandler.Invoke(null!, new ErrorEventArgs(e));
		}
	}
}

